#include <stdlib.h>
#include <stdbool.h> // Needed for bool type

#define MAX_ELEMENT 1000 // Maximum value used for counting in integer anagrams

// Check if a number is prime
bool is_prime(int number) {
    if (number <= 1) return false;

    for (int i = 2; i < number; i++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}

// Calculate the number of items that can fit given density and volume
int storage_capacity(float density, float volume) {
    if (volume <= 0) {
        return 0;
    }
    return (int)(density / volume);
}

// Swap two integers
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Find the maximum element in an array
int array_max(const int *array, int length) {
    int max_value = array[0];

    for (int i = 1; i < length; i++) {
        if (array[i] > max_value) {
            max_value = array[i];
        }
    }
    return max_value;
}

// Apply a function to each element of an array
void array_map(int *array, int length, int func(int)) {
    if (func == NULL) return;

    for (int i = 0; i < length; i++) {
        array[i] = func(array[i]);
    }
}

// Create a copy of an array
int *copy_array(const int *array, int length) {
    if (array == NULL) return NULL;

    int *copy = (int *)malloc(length * sizeof(int));
    if (copy == NULL) return NULL;

    for (int i = 0; i < length; i++) {
        copy[i] = array[i];
    }
    return copy;
}

// Create a deep copy of an array of arrays
int **copy_array_of_arrays(const int **arrays, const int *lengths, int array_count) {
    if (arrays == NULL || lengths == NULL) return NULL;

    int **new_arrays = (int **)malloc(array_count * sizeof(int *));
    if (new_arrays == NULL) return NULL;

    for (int i = 0; i < array_count; i++) {
        if (arrays[i] == NULL) {
            new_arrays[i] = NULL;
        } else {
            new_arrays[i] = (int *)malloc(lengths[i] * sizeof(int));
            if (new_arrays[i] == NULL) {
                for (int j = 0; j < i; j++) free(new_arrays[j]);
                free(new_arrays);
                return NULL;
            }
            for (int k = 0; k < lengths[i]; k++) {
                new_arrays[i][k] = arrays[i][k];
            }
        }
    }
    return new_arrays;
}

// Free memory of an array of arrays and their lengths
void free_array_of_arrays(int **arrays, int *lengths, int array_count) {
    if (arrays == NULL || lengths == NULL) return;

    for (int i = 0; i < array_count; i++) {
        if (arrays[i] != NULL) free(arrays[i]);
    }
    free(arrays);
    free(lengths);
}

// Sort an array in ascending order using bubble sort
void bubble_sort(int *array, int length) {
    if (array == NULL) return;

    for (int i = 0; i < length - 1; i++) {
        for (int j = 0; j < length - 1 - i; j++) {
            if (array[j] > array[j + 1]) {
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}

// Check if two arrays are equal
bool array_equal(const int *array1, int length1, const int *array2, int length2) {
    if (array1 == NULL && array2 == NULL) return true;
    if (array1 == NULL || array2 == NULL) return false;
    if (length1 != length2) return false;

    for (int i = 0; i < length1; i++) {
        if (array1[i] != array2[i]) return false;
    }
    return true;
}

// Check if two arrays are integer anagrams (contain the same elements in any order)
bool integer_anagrams(const int *array1, int length1, const int *array2, int length2) {
    if (array1 == NULL || array2 == NULL) return false;
    if (length1 != length2) return false;

    int *count1 = (int *)malloc(MAX_ELEMENT * sizeof(int));
    int *count2 = (int *)malloc(MAX_ELEMENT * sizeof(int));
    if (count1 == NULL || count2 == NULL) {
        free(count1);
        free(count2);
        return false;
    }

    for (int i = 0; i < MAX_ELEMENT; i++) {
        count1[i] = 0;
        count2[i] = 0;
    }

    for (int i = 0; i < length1; i++) {
        if (array1[i] >= 0 && array1[i] < MAX_ELEMENT) count1[array1[i]]++;
    }
    for (int i = 0; i < length2; i++) {
        if (array2[i] >= 0 && array2[i] < MAX_ELEMENT) count2[array2[i]]++;
    }

    bool result = true;
    for (int i = 0; i < MAX_ELEMENT; i++) {
        if (count1[i] != count2[i]) {
            result = false;
            break;
        }
    }

    free(count1);
    free(count2);
    return result;
}
